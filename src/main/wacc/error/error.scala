package wacc.error

import wacc.syntax.*

/** Types of errors that can be generated by the frontend. */
enum ErrorLines {
    /** Default error. */
    case VanillaError(unexpected: Option[ErrorItem], expected: Set[ErrorItem], reasons: Set[String], line: Seq[String])
    /** Specialised error. */
    case SpecialisedError(msgs: Set[String], line: Seq[String])
}

/** Contains the main error data structures used by the frontend. */
object errors {
    /** Describes the shared structure of printing all errors. */
    sealed trait WaccError(pos: bridges.Position, source: String, lines: ErrorLines) {
        val errorType: String

        override def toString: String = {
            val sb = new StringBuilder
            val whitespace = s"\n${" " * WaccErrorBuilder.Indent}"

            sb.append(s"$errorType in $source at row ${pos._1}, column ${pos._2}:")
            lines match {
                case ErrorLines.VanillaError(unexpected, expected, reasons, line) =>
                    val formattedUnexpected = unexpected.getOrElse("end of file")
                    val sortedExpected = expected.toSeq.sortBy(_.toString)
                    val formattedExpected = 
                        if (sortedExpected.isEmpty) "" 
                        else if (sortedExpected.length == 1) sortedExpected.head
                        else sortedExpected.init.mkString(", ") + " or " + sortedExpected.last
                    
                    if (unexpected.nonEmpty) {
                        sb.append(s"${whitespace}unexpected: $formattedUnexpected")
                    }
                    if (expected.nonEmpty) {
                        sb.append(s"${whitespace}expected: $formattedExpected")
                    }
                    sb.append(s"${whitespace}${reasons.mkString(s"${whitespace}")}")
                    sb.append(s"${whitespace}${line.mkString(s"${whitespace}")}")
                
                case ErrorLines.SpecialisedError(msgs, line) =>
                    sb.append(s"${whitespace}${msgs.mkString(", ")}")
                    sb.append(s"${whitespace}${line.mkString(s"${whitespace}")}")
            }
            sb.append("\n")
            sb.toString()
        }
    }

    /** Error that occurs during the syntactic analysis phase. */
    case class SyntaxError(pos: bridges.Position, source: String, lines: ErrorLines) extends WaccError(pos, source, lines) {
        override val errorType: String = "Syntax Error"
    }
    /** Error that occurs during the semantic analysis phase. */
    case class SemanticError(pos: bridges.Position, source: String, lines: ErrorLines, errTy: String) extends WaccError(pos, source, lines) {
        override val errorType: String = errTy
    }
    /** Error that occurs during the file reading phase. */
    case object IOError extends WaccError(bridges.NoPosition, "", ErrorLines.VanillaError(None, Set.empty, Set.empty, Seq.empty)) {
        override val errorType: String = "IOException caused"
    }
}

/** Builder object for generating error messages.
  * 
  * Contains common methods for generating error messages.
  */ 
object WaccErrorBuilder {
    /** Default parameters of the error message. */
    final val ErrorLineStart = "|"
    final val NumLinesBefore = 1
    final val NumLinesAfter = 1
    final val Indent = 2

    /** Generates the code segment where the error occurred. */
    def lineInfo(line: String, linesBefore: Seq[String], linesAfter: Seq[String], lineNum: Int, errorPointsAt: Int, errorWidth: Int): Seq[String] = {
        Seq.concat(
            linesBefore.map(inputLine(_, lineNum - 1)),
            Seq(inputLine(line, lineNum), caretLine(errorPointsAt, errorWidth, lineNum)),
            linesAfter.map(inputLine(_, lineNum + 1)),
        )
    }

    /** Adds line number information to the code segment. */
    def inputLine(line: String, lineNum: Int): String = s"${" " * Indent}$lineNum: $ErrorLineStart$line"

    /** Adds caret information to the code segment. */
    def caretLine(caretAt: Int, caretWidth: Int, lineNum: Int): String =
        s"${" " * (ErrorLineStart.length + caretAt + Indent * 2 + lineNum.toString.length)}${"^" * caretWidth}"
}
